<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jogo de Digita√ß√£o (Firebase)</title>

  <!-- Firebase SDKs (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg-color:#e6f2ff;
      --text-color:#333;
      --success-color:#d4edda;
      --error-color:#f8d7da;
      --primary-btn:#4CAF50;
      --secondary-btn:#FF9800;
      --danger-btn:#d32f2f;
      --panel-bg:#ffffffcc;
    }

    body{
      font-family: Arial, Helvetica, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      text-align:center;
      margin:0;
      display:flex;
      flex-direction:column;
      height:100vh;
      transition: background-color .25s;
    }

    body.flash-green{ background-color: var(--success-color); }
    body.flash-red{ background-color: var(--error-color); }

    header{
      padding: 18px;
      background:white;
      box-shadow:0 2px 5px rgba(0,0,0,.1);
      position: relative;
    }

    h2{ margin: 8px 0; }

    .meta-row{
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      margin-top:8px;
      color:#555;
      font-size:1.05rem;
    }

    .pill{
      background:#f3f6ff;
      border:1px solid #d9e3ff;
      padding:6px 10px;
      border-radius:999px;
    }

    .progress-container{
      width: 88%;
      max-width: 740px;
      height: 18px;
      background:#ddd;
      border-radius: 10px;
      margin: 10px auto;
      overflow:hidden;
    }

    .progress-bar{
      height:100%;
      width:0%;
      background:#4CAF50;
      transition: width .22s ease;
    }

    .stars{
      font-size:1.7rem;
      margin-top:8px;
    }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:18px;
      position:relative;
      overflow-y:auto;
    }

    /* input oculto para Mac/acentos */
    #hidden-input{
      position:absolute;
      opacity:0;
      pointer-events:none;
    }

    #feedback-msg{
      font-size:1.25rem;
      font-weight:bold;
      min-height:2.2rem;
      margin: 6px 0 10px;
      color:#555;
    }

    #text-display{
      font-size:3rem;
      letter-spacing:2px;
      background:white;
      padding: 18px 34px;
      border-radius:15px;
      box-shadow:0 4px 10px rgba(0,0,0,.1);
      margin-bottom:16px;
      max-width:92%;
      max-height: 45vh;
      overflow-y:auto;
      text-align:left;
      line-height:1.5;
      cursor:text;
      user-select:none;
      word-wrap: break-word;
    }

    .char{ color:#cfcfcf; }
    .char.correct{ color:#28a745; font-weight:bold; }
    .char.current{
      color:#007bff;
      text-decoration: underline;
      font-weight:bold;
      background:#e6f2ff;
    }

    button{
      font-size:1.35rem;
      padding: 14px 34px;
      background: var(--primary-btn);
      color:white;
      border:none;
      border-radius:10px;
      cursor:pointer;
      box-shadow:0 4px 6px rgba(0,0,0,.2);
      margin:8px;
    }

    #change-text-btn{
      background: var(--secondary-btn);
      display:none;
    }

    .result-box{
      max-width: 900px;
      width: 92%;
      margin-top: 8px;
      background: #ffffff;
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow:0 4px 10px rgba(0,0,0,.08);
      text-align:left;
      display:none;
    }
    .result-box h3{ margin: 6px 0 10px; }
    .result-box .small{ color:#666; font-size: .95rem; }
    .result-box .line{ margin:6px 0; }
    .result-box .ok{ color:#1b7f35; font-weight:bold; }
    .result-box .bad{ color:#b00020; font-weight:bold; }
    .hr{ height:1px; background:#eee; margin:10px 0; }

    /* Painel fixo de sess√£o */
    .session-panel{
      position:absolute;
      right:12px;
      top:12px;
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:flex-end;
      background: var(--panel-bg);
      backdrop-filter: blur(6px);
      padding:10px 12px;
      border-radius:14px;
      border:1px solid #eaeaea;
      max-width:260px;
    }
    .session-actions{
      display:flex;
      gap:6px;
    }
    .session-panel .who{
      font-size:.9rem;
      color:#333;
      background:#f3f6ff;
      border:1px solid #d9e3ff;
      padding:4px 8px;
      border-radius:8px;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      text-align:right;
    }
    .mini-btn{
      font-size: .95rem;
      padding: 8px 10px;
      margin:0;
      border-radius: 10px;
      box-shadow:none;
    }
    #reset-btn{
      background:#f59e0b;
      color:#fff;
    }
    #save-exit-btn{ background: var(--secondary-btn); }
    #logout-btn{ background: var(--danger-btn); }

    .loading-overlay{
      position:fixed;
      inset:0;
      background:#00000055;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:999;
      color:white;
      font-size:1.2rem;
      display:none;
    }
    .loading-card{
      background:#111;
      padding:16px 18px;
      border-radius:12px;
      width:min(520px, 92%);
      text-align:left;
    }
    .loading-card .small{ color:#ddd; font-size:.95rem; margin-top:6px; }
  </style>
</head>

<body>
<header>
  <div class="session-panel">
    <div class="session-actions">
      <button class="mini-btn" id="reset-btn" title="Resetar progresso">üîÑ Resetar</button>
      <button class="mini-btn" id="save-exit-btn">üíæ Salvar e Sair</button>
      <button class="mini-btn" id="logout-btn">üö™ Logout</button>
    </div>
    <div class="who" id="whoami">Carregando...</div>
  </div>

  <h2>
    <span id="difficulty-label">Dificuldade: F√°cil</span> ‚Äî
    Fase <span id="phase-number">1</span>/8
    (<span id="overall-phase">1</span>/24):
    <span id="phase-name">O B√°sico</span>
  </h2>

  <div class="progress-container">
    <div class="progress-bar" id="progress"></div>
  </div>

  <div class="meta-row">
    <span class="pill">Tempo: <strong><span id="time-display">0.0</span>s</strong></span>
    <span class="pill">Erros: <strong><span id="errors-display">0</span></strong></span>
    <span class="pill">Confort√°vel: <strong><span id="target-display">0.0</span>s</strong></span>
    <span class="pill">Ideal: <strong><span id="ideal-display">0.0</span>s</strong></span>
    <span class="pill">R√°pido: <strong><span id="fast-display">0.0</span>s</strong></span>
    <span class="pill">Nota: <strong><span id="phase-score-display">‚Äî</span>%</strong></span>
  </div>

  <div class="stars" id="stars-display">‚≠ê‚≠ê‚≠ê</div>
</header>

<main>
  <p id="feedback-msg">Carregando sess√£o...</p>

  <input id="hidden-input" type="text" autocomplete="off" spellcheck="false" />
  <div id="text-display">Aguarde...</div>

  <div>
    <button id="action-btn">Come√ßar</button>
    <button id="change-text-btn">Trocar Texto</button>
  </div>

  <div class="result-box" id="final-report">
    <h3>Relat√≥rio Final</h3>
    <div class="line">M√©dia geral: <strong><span id="final-average">0</span>%</strong></div>
    <div class="line small" id="final-status"></div>
    <div class="hr"></div>
    <div class="small" id="final-breakdown"></div>
  </div>
</main>

<div class="loading-overlay" id="loading">
  <div class="loading-card">
    <div><strong>Sincronizando com o Firebase...</strong></div>
    <div class="small" id="loading-msg">Carregando progresso.</div>
  </div>
</div>

<script>
/* =========================
   Firebase init
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyCr81cMa2T_iZmxy2tNOjYydSnrs3aSmtk",
  authDomain: "jogo-digitacao.firebaseapp.com",
  projectId: "jogo-digitacao",
  storageBucket: "jogo-digitacao.firebasestorage.app",
  messagingSenderId: "903019411681",
  appId: "1:903019411681:web:ea572018fb9913ca2f9fa0"
};

if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp;
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);

/* =========================
   UI refs
   ========================= */
const whoami = document.getElementById("whoami");
const saveExitBtn = document.getElementById("save-exit-btn");
const logoutBtn = document.getElementById("logout-btn");
const resetBtn = document.getElementById("reset-btn");

const loadingOverlay = document.getElementById("loading");
const loadingMsg = document.getElementById("loading-msg");

const textDisplay = document.getElementById("text-display");
const hiddenInput = document.getElementById("hidden-input");
const feedbackMsg = document.getElementById("feedback-msg");
const actionBtn = document.getElementById("action-btn");
const changeTextBtn = document.getElementById("change-text-btn");
const progress = document.getElementById("progress");
const starsDisplay = document.getElementById("stars-display");
const phaseNumber = document.getElementById("phase-number");
const overallPhase = document.getElementById("overall-phase");
const phaseName = document.getElementById("phase-name");
const difficultyLabel = document.getElementById("difficulty-label");
const timeDisplay = document.getElementById("time-display");
const errorsDisplay = document.getElementById("errors-display");
const targetDisplay = document.getElementById("target-display");
const idealDisplay = document.getElementById("ideal-display");
const fastDisplay = document.getElementById("fast-display");
const phaseScoreDisplay = document.getElementById("phase-score-display");
const finalReport = document.getElementById("final-report");
const finalAverage = document.getElementById("final-average");
const finalStatus = document.getElementById("final-status");
const finalBreakdown = document.getElementById("final-breakdown");

function showLoading(msg){
  loadingMsg.innerText = msg || "Carregando...";
  loadingOverlay.style.display = "flex";
}
function hideLoading(){
  loadingOverlay.style.display = "none";
}

/* =========================
   util
   ========================= */
function shuffle(arr){
  let i=arr.length, j;
  while(i){
    j = Math.floor(Math.random()*i--);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function fmt1(n){ return (Math.round(n*10)/10).toFixed(1); }
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function totalCharsOfItems(items){ return items.reduce((acc,s)=>acc+(s? s.length:0),0); }

function flashScreen(type){
  document.body.classList.add(`flash-${type}`);
  setTimeout(() => document.body.classList.remove(`flash-${type}`), 220);
}

/* =========================
   pools
   ========================= */
const poolVowels = ["A","E","I","O","U"];
const poolConsonants = ["B","C","√á","D","F","G","H","J","K","L","M","N","P","Q","R","S","T","V","X","Z","W","Y"];
const poolSyllables = [
  "BA","BE","BI","BO","BU","CA","CE","CI","CO","CU","DA","DE","DI","DO","DU",
  "FA","FE","FI","FO","FU","GA","GE","GI","GO","GU","LA","LE","LI","LO","LU",
  "MA","ME","MI","MO","MU","NA","NE","NI","NO","NU","PA","PE","PI","PO","PU",
  "RA","RE","RI","RO","RU","SA","SE","SI","SO","SU","TA","TE","TI","TO","TU",
  "VA","VE","VI","VO","VU","XA","XE","XI","XO","XU","√áA","√áO","√áU"
];
const poolShortWords = [
  "PAI","M√ÉE","V√ì","V√î","TIA","TIO","BEM","MAL","SIM","N√ÉO","SOL","LUA","DIA","PAZ","LUZ","MAR","COR",
  "F√â","P√ÉO","S√ÉO","C√âU","M√ÉO","P√â","CH√Å","S√ì","J√Å","N√â","T√Å","P√î","D√ä","V√ä","L√ä","N√ìS","ELA","ELE",
  "C√ÉO","G√ÅS","RUA","RIO","VOZ","FLOR","SAL","MEL","BOM","BOA","FIM","TREM","LEVE","FORTE",
  "AQUI","ALI","ISSO","TUDO","HOJE","AMANH√É","ONTEM"
];
const poolMediumWords = [
  "MESA","CASA","BOLO","CAF√â","GATO","RATO","DOCE","√ÅGUA","FOGO","TERRA","VENTO","LIVRO","LETRA","TEMPO","NOITE",
  "MANH√É","TARDE","AMOR","SA√öDE","FOR√áA","F√ÅCIL","DIF√çCIL","PR√ÅTICA","M√öSICA","JANELA","PORTA","CHAVE","ESCOLA",
  "AMIGO","AMIGA","CIDADE","PRA√áA","PONTE","CARRO","√îNIBUS","AVI√ÉO","PRAIA","ILHA","FAM√çLIA","VIAGEM","COZINHA",
  "QUARTO","SALA","JARDIM","SORRISO","RISADA","CORRER","ANDAR","PULAR","NADAR","BRINCAR","JOGAR","ESTUDAR",
  "TRABALHO","SONHO","VIT√ìRIA","DERROTA","CADERNO","L√ÅPIS","CANETA","TECLADO","TELA","SENHA","ONLINE","D√öVIDA",
  "RESPOSTA","CORA√á√ÉO","EMO√á√ÉO","RAZ√ÉO","HIST√ìRIA","MEM√ìRIA","CULTURA","CI√äNCIA","F√çSICA","QU√çMICA","R√ÅPIDO",
  "LENTO","QUENTE","FRIO","√ìTIMO","√öTIL","PRESSA","CALMA"
];
const poolLongWords = [
  "CACHORRO","MERCADO","TELEFONE","COMPUTADOR","INTERNET","TRABALHADOR","NATUREZA","ESPERAN√áA","FELICIDADE","AMIZADE",
  "RESPONS√ÅVEL","CONFIAN√áA","CONHECIMENTO","APRENDIZADO","DESAFIO","CONCENTRA√á√ÉO","DISCIPLINA","PERSIST√äNCIA",
  "ORGANIZA√á√ÉO","CRIATIVIDADE","COMUNICA√á√ÉO","ATEN√á√ÉO","PRODUTIVIDADE","EXPERI√äNCIA","INSPIRA√á√ÉO",
  "PROGRAMA√á√ÉO","JAVASCRIPT","DESENVOLVIMENTO","TECNOLOGIA","INFORMA√á√ÉO","CONEX√ÉO","ALGORITMO","ESTRUTURA",
  "UNIVERSIDADE","BIBLIOTECA","LABORAT√ìRIO","ELETRICIDADE","ENGENHARIA","MATEM√ÅTICA","ESTAT√çSTICA","PESQUISA",
  "RESPIRA√á√ÉO","NUTRI√á√ÉO","EXERC√çCIO","CONDICIONAMENTO","SUPERA√á√ÉO","MOTIVA√á√ÉO"
];
const poolPhrases = [
  "Bom dia! Tudo bem com voc√™?",
  "Hoje eu tomei um caf√© bem forte.",
  "A pr√°tica leva √† perfei√ß√£o, n√£o desista!",
  "Voc√™ consegue: foco, calma e precis√£o.",
  "Amanh√£ cedo eu vou √† escola.",
  "O c√©u est√° lindo e o vento est√° leve.",
  "Pegue a chave, feche a porta e venha.",
  'Minha av√≥ disse: "com f√©, tudo melhora".',
  "Eu n√£o quero pressa; quero const√¢ncia.",
  "Olhe pela janela: que paisagem incr√≠vel!",
  "Voc√™ j√° digitou com aten√ß√£o hoje?",
  "A m√∫sica acalma o cora√ß√£o e melhora o humor."
];
const literaryTexts = [
  "Marcela amou-me durante quinze meses e onze contos de r√©is; nada menos.",
  "O poeta √© um fingidor. Finge t√£o completamente que chega a fingir que √© dor a dor que deveras sente.",
  "Renda-se, como eu me rendi. Mergulhe no que voc√™ n√£o conhece como eu mergulhei.",
  "O correr da vida embrulha tudo. A vida √© assim: esquenta e esfria, aperta e da√≠ afrouxa."
];

/* =========================
   difficulties (CPS) - NOVAS METAS
   ========================= */
const difficulties = [
  { key:"easy",   label:"F√°cil",   picks:{ consonants:12, syllables:20, short:28, medium:24, long:18, phrases:10 }, cps:{ comfort:1.0, ideal:1.4, fast:1.8 }, strictFromPhase2:false },
  { key:"medium", label:"M√©dio",   picks:{ consonants:16, syllables:26, short:36, medium:32, long:24, phrases:14 }, cps:{ comfort:1.2, ideal:1.6, fast:2.0 }, strictFromPhase2:false },
  { key:"hard",   label:"Dif√≠cil", picks:{ consonants:18, syllables:30, short:42, medium:38, long:28, phrases:16 }, cps:{ comfort:1.2, ideal:1.6, fast:2.0 }, strictFromPhase2:true }
];

/* =========================
   state
   ========================= */
let currentUser = null;
let userProfile = null;

let difficultyIndex = 0;
let currentPhaseIndex = 0;
let currentWordIndex = 0;
let currentText = "";
let charIndex = 0;
let errors = 0;
let isPlaying = false;

let phases = [];
let phasePlanSaved = null;

let phaseStartMs = 0;
let phaseElapsed = 0;
let timerInterval = null;

let phaseGrades = [];

let isComposing = false;
let dirty = false;
let autosaveInterval = null;

let phaseChars = 0;
let targetComfort = 0;
let targetIdeal = 0;
let targetFast = 0;

/* =========================
   Firestore helpers
   ========================= */
function docRef(col){ return db.collection(col).doc(currentUser.uid); }

async function loadUserProfile(){
  const snap = await docRef("users").get();
  return snap.exists ? snap.data() : null;
}
async function loadProgress(){
  const snap = await docRef("progress").get();
  return snap.exists ? snap.data() : null;
}
async function loadGrades(){
  const snap = await docRef("grades").get();
  return snap.exists ? snap.data() : null;
}

function markDirty(){ dirty = true; }

async function saveProgress(reason){
  if (!currentUser) return;
  await docRef("progress").set({
    difficultyIndex,
    currentPhaseIndex,
    currentWordIndex,
    charIndex,
    currentText,
    phasePlan: phasePlanSaved,
    updatedAt: serverTimestamp(),
    lastSaveReason: reason || "autosave"
  }, { merge:true });
  dirty = false;
}

async function saveGrades(){
  if (!currentUser) return;
  const total = phaseGrades.reduce((acc,p)=>acc+(p?.score ?? 0), 0);
  const count = phaseGrades.filter(Boolean).length;
  const avg = count ? Math.round(total / count) : 0;
  const approved = avg >= 70;

  await docRef("grades").set({
    phases: phaseGrades,
    average: avg,
    approved,
    updatedAt: serverTimestamp()
  }, { merge:true });
}

/* =========================
   Build phases
   ========================= */
function buildPhasesForDifficulty(diff){
  const plan = {
    name: diff.label,
    createdAt: Date.now(),
    phases: [
      { name:"Vogais", type:"list", items: shuffle([...poolVowels]) },
      { name:"Consoantes", type:"list", items: shuffle([...poolConsonants]).slice(0, Math.min(diff.picks.consonants, poolConsonants.length)) },
      { name:"S√≠labas", type:"list", items: shuffle([...poolSyllables]).slice(0, Math.min(diff.picks.syllables, poolSyllables.length)) },
      { name:"Palavras Curtas", type:"list", items: shuffle([...poolShortWords]).slice(0, Math.min(diff.picks.short, poolShortWords.length)) },
      { name:"Palavras M√©dias", type:"list", items: shuffle([...poolMediumWords]).slice(0, Math.min(diff.picks.medium, poolMediumWords.length)) },
      { name:"Palavras Longas", type:"list", items: shuffle([...poolLongWords]).slice(0, Math.min(diff.picks.long, poolLongWords.length)) },
      { name:"Frases", type:"list", items: shuffle([...poolPhrases]).slice(0, Math.min(diff.picks.phrases, poolPhrases.length)) },
      { name:"Texto Liter√°rio", type:"final", items: [] }
    ]
  };
  phasePlanSaved = plan;
  phases = plan.phases;
}
function restorePhasePlan(savedPlan){
  phasePlanSaved = savedPlan;
  phases = savedPlan?.phases || [];
}

/* =========================
   UI helpers
   ========================= */
function setButton(mode, text){
  actionBtn.dataset.mode = mode;
  actionBtn.innerText = text;
  actionBtn.style.display = "inline-block";
}
function hideButton(){ actionBtn.style.display = "none"; }

function resetPhaseStats(){
  errors = 0;
  errorsDisplay.innerText = "0";
  starsDisplay.innerText = "‚≠ê‚≠ê‚≠ê";
  phaseElapsed = 0;
  timeDisplay.innerText = "0.0";
  targetDisplay.innerText = "0.0";
  idealDisplay.innerText = "0.0";
  fastDisplay.innerText = "0.0";
  phaseScoreDisplay.innerText = "‚Äî";
}

function overallPhaseNumber(){
  return (difficultyIndex * 8) + (currentPhaseIndex + 1);
}

function updateHeader(){
  const diff = difficulties[difficultyIndex];
  difficultyLabel.innerText = `Dificuldade: ${diff.label}`;
  phaseNumber.innerText = String(currentPhaseIndex + 1);
  overallPhase.innerText = String(overallPhaseNumber());
  phaseName.innerText = phases[currentPhaseIndex]?.name || "‚Äî";
}

function renderText(text){
  textDisplay.innerHTML = "";
  for (let i=0;i<text.length;i++){
    const sp = document.createElement("span");
    sp.innerText = text[i];
    sp.classList.add("char");
    if (i===0) sp.classList.add("current");
    textDisplay.appendChild(sp);
  }
}

function applyCharProgress(){
  const spans = textDisplay.querySelectorAll("span");
  for (let i=0; i<spans.length; i++){
    spans[i].classList.remove("current");
    if (i < charIndex) spans[i].classList.add("correct");
  }
  if (spans[charIndex]) spans[charIndex].classList.add("current");
}

function updateProgressUI(){
  const phase = phases[currentPhaseIndex];
  if (phase?.type === "list"){
    const total = phase.items.length || 1;
    progress.style.width = ((currentWordIndex/total)*100) + "%";
  } else {
    progress.style.width = currentText ? ((charIndex/currentText.length)*100) + "%" : "0%";
  }
}
function updateFinalProgress(){
  if (phases[currentPhaseIndex]?.type === "final" && currentText){
    progress.style.width = ((charIndex/currentText.length)*100) + "%";
  }
}

/* =========================
   Targets com lat√™ncia
   ========================= */
function phaseLatency(){
  const phaseNum = currentPhaseIndex + 1;
  const isFinal = phases[currentPhaseIndex]?.type === "final";
  if (isFinal) return 0.3;
  if (phaseNum === 1) return 1.8;
  if (phaseNum === 2) return 1.2;
  if (phaseNum === 3) return 0.6;
  return 0.4;
}

function computeTargets(chars){
  const safeChars = Math.max(chars, 1);
  const { comfort, ideal, fast } = difficulties[difficultyIndex].cps;
  const latency = phaseLatency();

  targetComfort = latency + (safeChars / comfort);
  targetIdeal   = latency + (safeChars / ideal);
  targetFast    = latency + (safeChars / fast);

  targetDisplay.innerText = fmt1(targetComfort);
  idealDisplay.innerText  = fmt1(targetIdeal);
  fastDisplay.innerText   = fmt1(targetFast);
}

function currentTimeTier(elapsed){
  if (elapsed <= targetFast) return "fast";
  if (elapsed <= targetIdeal) return "ideal";
  if (elapsed <= targetComfort) return "comfort";
  return "slow";
}

/* =========================
   Timer
   ========================= */
function startTimerAndTarget(){
  const phase = phases[currentPhaseIndex];
  if (phase.type === "list") phaseChars = totalCharsOfItems(phase.items);
  else phaseChars = currentText ? currentText.length : 0;

  computeTargets(phaseChars);

  phaseStartMs = performance.now();
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!isPlaying) return;
    phaseElapsed = (performance.now() - phaseStartMs)/1000;
    timeDisplay.innerText = fmt1(phaseElapsed);
  }, 100);
}

function stopTimer(){
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = null;
  phaseElapsed = phaseStartMs ? (performance.now() - phaseStartMs)/1000 : 0;
  timeDisplay.innerText = fmt1(phaseElapsed);
}

function pauseTimer(){
  if (timerInterval){
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

function resumeTimer(){
  if (!isPlaying) return;
  phaseStartMs = performance.now() - (phaseElapsed * 1000);
  timerInterval = setInterval(() => {
    if (!isPlaying) return;
    phaseElapsed = (performance.now() - phaseStartMs)/1000;
    timeDisplay.innerText = fmt1(phaseElapsed);
  }, 100);
}

/* =========================
   Nota e estrelas
   ========================= */
function calculateStarsWithTime(errorsCount, elapsedSeconds){
  const diff = difficulties[difficultyIndex];
  const errorLimits = diff.key === "easy"
    ? { three: 2, two: 6 }
    : diff.key === "medium"
      ? { three: 1, two: 4 }
      : { three: 0, two: 2 };

  let starsByErrors = 1;
  if (errorsCount <= errorLimits.three) starsByErrors = 3;
  else if (errorsCount <= errorLimits.two) starsByErrors = 2;

  let starsByTime = 1;
  if (elapsedSeconds <= targetIdeal) starsByTime = 3;
  else if (elapsedSeconds <= targetComfort) starsByTime = 2;
  else starsByTime = 1;

  const finalStars = Math.min(starsByErrors, starsByTime);
  if (finalStars === 3) return "‚≠ê‚≠ê‚≠ê Excelente!";
  if (finalStars === 2) return "‚≠ê‚≠ê Muito bom!";
  return "‚≠ê Continue praticando!";
}

function computePhaseScore(errorsCount, elapsedSeconds){
  const chars = Math.max(phaseChars, 1);

  // Calcula a precis√£o (acertos)
  const accuracy = clamp((chars - errorsCount) / chars, 0, 1);
  const accuracyScore = Math.round(accuracy * 100);

  // Calcula a pontua√ß√£o base do tempo
  let timeScore = 60;
  if (elapsedSeconds <= targetFast) timeScore = 100;
  else if (elapsedSeconds <= targetIdeal) timeScore = 92;
  else if (elapsedSeconds <= targetComfort) timeScore = 82;
  else {
    const ratio = elapsedSeconds / Math.max(targetComfort, 0.1);
    timeScore = Math.round(clamp(82 - (ratio - 1) * 22, 60, 82));
  }

  // Nota bruta original (65% precis√£o, 35% tempo)
  let rawScore = Math.round(accuracyScore * 0.65 + timeScore * 0.35);

  // ==========================================
  // NOVA REGRA: O tempo define o TETO M√ÅXIMO da nota
  // ==========================================
  const tier = currentTimeTier(elapsedSeconds);
  let scoreCap = 100;
  
  if (tier === "fast") scoreCap = 100;
  else if (tier === "ideal") scoreCap = 90;
  else if (tier === "comfort") scoreCap = 80;
  else scoreCap = 70; // tier === "slow" (como no caso do teste de 145 segundos)

  // A nota final √© a menor entre a nota bruta e o teto permitido pelo tempo
  return clamp(Math.min(rawScore, scoreCap), 0, 100);
}
  
/* =========================
   Compara√ß√£o de caractere
   ========================= */
function isCharCorrect(typedChar, expectedChar){
  const diff = difficulties[difficultyIndex];
  const phaseNum = currentPhaseIndex + 1;
  const isFinal = phases[currentPhaseIndex]?.type === "final";

  if (isFinal) return typedChar === expectedChar;
  if (diff.strictFromPhase2 && phaseNum >= 2) return typedChar === expectedChar;
  return typedChar.toLowerCase() === expectedChar.toLowerCase();
}

/* =========================
   Load item / final text
   ========================= */
function loadItem(){
  const phase = phases[currentPhaseIndex];
  if (!phase) return;

  if (phase.type === "final"){
    loadFinalText();
    return;
  }

  currentText = phase.items[currentWordIndex];
  charIndex = 0;
  renderText(currentText);
  hiddenInput.value = "";
}

function loadFinalText(){
  if (!currentText || currentText.length < 5){
    const idx = Math.floor(Math.random() * literaryTexts.length);
    currentText = literaryTexts[idx];
  }
  renderText(currentText);
  phaseChars = currentText.length;
  computeTargets(phaseChars);

  changeTextBtn.style.display = "inline-block";
  hiddenInput.focus();
  hiddenInput.value = "";
}

/* =========================
   Game control
   ========================= */
function startGame(){
  finalReport.style.display = "none";
  feedbackMsg.innerText = "Digite a letra sublinhada.";
  changeTextBtn.style.display = "none";
  textDisplay.style.textAlign = "left";

  resetPhaseStats();
  hideButton();

  isPlaying = true;
  hiddenInput.focus();

  if (!currentText) loadItem();
  else {
    renderText(currentText);
    applyCharProgress();
  }

  updateHeader();
  updateProgressUI();
  startTimerAndTarget();
  markDirty();
}

function continueToNextPhase(){
  finalReport.style.display = "none";
  feedbackMsg.innerText = "Digite a letra sublinhada.";
  changeTextBtn.style.display = "none";
  textDisplay.style.textAlign = "left";

  resetPhaseStats();
  hideButton();

  isPlaying = true;
  hiddenInput.focus();

  currentText = "";
  loadItem();
  updateHeader();
  updateProgressUI();
  startTimerAndTarget();
  markDirty();
}

/* =========================
   Reset: fase ou jogo
   ========================= */
async function resetCurrentPhase(){
  // reinicia a fase atual e zera tempo/erros sem destruir o jogo todo
  stopTimer();
  errors = 0;
  currentWordIndex = 0;
  charIndex = 0;
  currentText = "";

  resetPhaseStats();
  feedbackMsg.innerText = "Fase reiniciada! Comece novamente.";
  textDisplay.style.textAlign = "left";

  isPlaying = true;
  loadItem();
  updateHeader();
  updateProgressUI();
  startTimerAndTarget();

  hiddenInput.focus();
  markDirty();
  await saveProgress("resetPhase");
}

async function resetProgressInFirestore(){
  if (!currentUser) return;
  await docRef("progress").set({
    difficultyIndex: 0,
    currentPhaseIndex: 0,
    currentWordIndex: 0,
    charIndex: 0,
    currentText: "",
    phasePlan: null,
    updatedAt: serverTimestamp()
  }, { merge: false });

  await docRef("grades").set({
    phases: [],
    average: 0,
    approved: false,
    updatedAt: serverTimestamp()
  }, { merge: false });
}

/* =========================
   Finish phase
   ========================= */
async function finishPhase(){
  stopTimer();
  isPlaying = false;
  progress.style.width = "100%";

  const starsText = calculateStarsWithTime(errors, phaseElapsed);
  starsDisplay.innerText = starsText;

  const phaseScore = computePhaseScore(errors, phaseElapsed);
  phaseScoreDisplay.innerText = String(phaseScore);

  const chars = Math.max(phaseChars, 1);
  const accuracyPct = Math.round(clamp((chars - errors) / chars, 0, 1) * 100);
  const cps = Math.round((chars / Math.max(phaseElapsed, 0.1)) * 100) / 100;
  const tier = currentTimeTier(phaseElapsed);

  if (!Array.isArray(phaseGrades)) phaseGrades = [];
  const idxOverall = overallPhaseNumber() - 1;

  phaseGrades[idxOverall] = {
    overallPhase: overallPhaseNumber(),
    difficulty: difficulties[difficultyIndex].label,
    phase: `${currentPhaseIndex + 1}/8 - ${phases[currentPhaseIndex].name}`,
    score: phaseScore,
    starsText,
    elapsed: Math.round(phaseElapsed * 10) / 10,
    errors,
    chars,
    accuracyPct,
    cps,
    targetComfort: Math.round(targetComfort * 10) / 10,
    targetIdeal: Math.round(targetIdeal * 10) / 10,
    targetFast: Math.round(targetFast * 10) / 10,
    timeTier: tier,
    savedAt: Date.now()
  };

  // avan√ßa fase
  currentPhaseIndex++;
  currentWordIndex = 0;
  charIndex = 0;
  currentText = "";
  changeTextBtn.style.display = "none";

  try{
    showLoading("Salvando notas e progresso...");
    await saveGrades();
    await saveProgress("finishPhase");
  } finally {
    hideLoading();
  }

  // troca dificuldade?
  if (currentPhaseIndex >= phases.length){
    difficultyIndex++;

    if (difficultyIndex >= difficulties.length){
      showFinalGradeAndDecide();
      return;
    }

    currentPhaseIndex = 0;
    currentWordIndex = 0;
    charIndex = 0;
    currentText = "";

    buildPhasesForDifficulty(difficulties[difficultyIndex]);
    updateHeader();

    feedbackMsg.innerText = `Dificuldade conclu√≠da! Agora: ${difficulties[difficultyIndex].label}.`;
    textDisplay.innerHTML = "üî• Nova dificuldade! Clique em Pr√≥xima Fase.";
    textDisplay.style.textAlign = "center";

    setButton("next", "Pr√≥xima Fase");
    markDirty();
    await saveProgress("newDifficulty");
    return;
  }

  updateHeader();
  feedbackMsg.innerText = "Fase conclu√≠da! " + starsText;
  textDisplay.innerHTML = "üåü";
  textDisplay.style.textAlign = "center";
  setButton("next", "Pr√≥xima Fase");
  markDirty();
}

/* =========================
   Final report
   ========================= */
function showFinalGradeAndDecide(){
  const total = phaseGrades.reduce((acc, p) => acc + (p?.score ?? 0), 0);
  const count = phaseGrades.filter(Boolean).length;
  const avg = count ? (total / count) : 0;
  const avgRound = Math.round(avg);

  finalAverage.innerText = String(avgRound);

  const byDiff = {};
  for (const p of phaseGrades){
    if (!p) continue;
    if (!byDiff[p.difficulty]) byDiff[p.difficulty] = [];
    byDiff[p.difficulty].push(p.score);
  }

  const lines = [];
  for (const key of Object.keys(byDiff)){
    const arr = byDiff[key];
    const a = arr.reduce((x,y)=>x+y,0)/arr.length;
    lines.push(`‚Ä¢ ${key}: ${Math.round(a)}%`);
  }

  finalBreakdown.innerHTML =
    `<div class="line"><strong>Resumo por dificuldade:</strong></div>` +
    lines.map(s => `<div class="line">${s}</div>`).join("") +
    `<div class="hr"></div>` +
    `<div class="line small">Regra: m√©dia ‚â• 70% = aprovado. Abaixo de 70% = reinicia a atividade.</div>`;

  finalReport.style.display = "block";

  if (avg >= 70){
    feedbackMsg.innerText = "Aprovado! ‚úÖ";
    textDisplay.innerHTML = "üèÜ‚úÖ PARAB√âNS! ‚úÖüèÜ";
    textDisplay.style.textAlign = "center";
    finalStatus.innerHTML = `<span class="ok">Status: APROVADO</span> ‚Äî M√©dia ‚â• 70%.`;
    setButton("restart", "Jogar de Novo (Opcional)");
  } else {
    feedbackMsg.innerText = "Nota abaixo de 70%. Voc√™ deve reiniciar. ‚ùå";
    textDisplay.innerHTML = "‚ùå REPROVADO ‚ùå";
    textDisplay.style.textAlign = "center";
    finalStatus.innerHTML = `<span class="bad">Status: REPROVADO</span> ‚Äî M√©dia < 70%.`;
    setButton("retry", "Reiniciar");
  }
}

/* =========================
   Input handling (Mac dead keys)
   ========================= */
function processTypedText(text){
  if (!text) return;
  for (const ch of text){
    if (!isPlaying) break;
    processTypedChar(ch);
  }
}

function processTypedChar(typedChar){
  const expectedChar = currentText[charIndex];
  const spans = textDisplay.querySelectorAll("span");
  if (!expectedChar || !spans[charIndex]) return;

  if (isCharCorrect(typedChar, expectedChar)){
    spans[charIndex].classList.remove("current");
    spans[charIndex].classList.add("correct");
    flashScreen("green");

    charIndex++;
    updateFinalProgress();
    markDirty();

    if (charIndex === currentText.length){
      const phase = phases[currentPhaseIndex];

      if (phase.type === "final"){
        finishPhase();
      } else {
        currentWordIndex++;
        if (currentWordIndex >= phase.items.length){
          finishPhase();
        } else {
          isPlaying = false;
          setTimeout(() => {
            loadItem();
            updateProgressUI();
            isPlaying = true;
            markDirty();
          }, 220);
        }
      }
    } else {
      spans[charIndex].classList.add("current");
      spans[charIndex].scrollIntoView({ behavior:"smooth", block:"center" });
    }
  } else {
    errors++;
    errorsDisplay.innerText = String(errors);
    flashScreen("red");
    markDirty();
  }
}

hiddenInput.addEventListener("compositionstart", () => { isComposing = true; });
hiddenInput.addEventListener("compositionend", (event) => {
  isComposing = false;
  if (!isPlaying){ hiddenInput.value = ""; return; }
  const composed = (event.data ?? hiddenInput.value);
  processTypedText(composed);
  hiddenInput.value = "";
});

hiddenInput.addEventListener("input", (event) => {
  if (!isPlaying){ hiddenInput.value = ""; return; }
  if (event.isComposing || isComposing || event.inputType === "insertCompositionText") return;
  const data = (event.data ?? hiddenInput.value);
  processTypedText(data);
  hiddenInput.value = "";
});

/* =========================
   Buttons
   ========================= */
actionBtn.addEventListener("click", async () => {
  const mode = actionBtn.dataset.mode || "start";
  if (mode === "start") startGame();
  else if (mode === "next") continueToNextPhase();
  else if (mode === "retry") { await resetProgressInFirestore(); location.reload(); }
  else if (mode === "restart") location.reload();
});

changeTextBtn.addEventListener("click", () => {
  currentText = "";
  loadFinalText();
  markDirty();
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !isPlaying){
    const mode = actionBtn.dataset.mode || "start";
    if (mode === "start") startGame();
    else if (mode === "next") continueToNextPhase();
  }
});

/* Reset button: choose phase or full reset */
resetBtn.addEventListener("click", async () => {
  if (!currentUser) return;

  const wasPlaying = isPlaying;
  pauseTimer();
  isPlaying = false;

  const choice = prompt(
    "‚ö†Ô∏è RESET\n\n" +
    "1 ‚Üí Resetar APENAS a fase atual (zera tempo e recome√ßa)\n" +
    "2 ‚Üí Resetar TODO o jogo (apaga progresso e notas)\n\n" +
    "Digite 1 ou 2. Cancelar = voltar."
  );

  if (choice === null){
    isPlaying = wasPlaying;
    if (wasPlaying) resumeTimer();
    hiddenInput.focus();
    return;
  }

  if (choice === "1"){
    isPlaying = true;
    await resetCurrentPhase();
    return;
  }

  if (choice === "2"){
    const confirmAll = confirm(
      "‚ö†Ô∏è ATEN√á√ÉO!\n\n" +
      "Isso ir√° APAGAR TODO o progresso e notas.\n" +
      "Essa a√ß√£o N√ÉO pode ser desfeita.\n\n" +
      "Deseja continuar?"
    );
    if (!confirmAll){
      isPlaying = wasPlaying;
      if (wasPlaying) resumeTimer();
      hiddenInput.focus();
      return;
    }

    try{
      showLoading("Resetando jogo...");
      await resetProgressInFirestore();
    } finally {
      hideLoading();
    }
    location.reload();
    return;
  }

  // op√ß√£o inv√°lida: volta
  isPlaying = wasPlaying;
  if (wasPlaying) resumeTimer();
  hiddenInput.focus();
});

/* Save & exit */
saveExitBtn.addEventListener("click", async () => {
  if (!currentUser){ location.href = "index.html"; return; }
  try{
    showLoading("Salvando e saindo...");
    await saveGrades();
    await saveProgress("saveExit");
  } finally {
    hideLoading();
  }
  await auth.signOut();
  location.href = "index.html";
});

/* Logout */
logoutBtn.addEventListener("click", async () => {
  await auth.signOut();
  location.href = "index.html";
});

/* beforeunload warn */
window.addEventListener("beforeunload", (e) => {
  if (dirty){
    e.preventDefault();
    e.returnValue = "";
  }
});

/* =========================
   Session init
   ========================= */
async function initAfterAuth(user){
  currentUser = user;

  showLoading("Carregando perfil...");
  userProfile = await loadUserProfile();

  if (!userProfile){
    hideLoading();
    alert("Perfil n√£o encontrado.");
    location.href = "index.html";
    return;
  }

  whoami.innerText = `${userProfile.nome || "Aluno"} (${userProfile.cpf || "CPF"})`;

  if (userProfile.role === "teacher"){
    hideLoading();
    location.href = "teacher.html";
    return;
  }

  showLoading("Carregando progresso...");
  const progressData = await loadProgress();
  showLoading("Carregando notas...");
  const gradesData = await loadGrades();

  phaseGrades = (gradesData && Array.isArray(gradesData.phases)) ? gradesData.phases : [];

  if (progressData && progressData.phasePlan && progressData.phasePlan.phases){
    difficultyIndex = progressData.difficultyIndex ?? 0;
    restorePhasePlan(progressData.phasePlan);

    currentPhaseIndex = progressData.currentPhaseIndex ?? 0;
    currentWordIndex = progressData.currentWordIndex ?? 0;
    charIndex = progressData.charIndex ?? 0;
    currentText = progressData.currentText ?? "";

    feedbackMsg.innerText = "Progresso carregado! Clique em ‚ÄúContinuar‚Äù.";
    setButton("start", "Continuar");
  } else {
    difficultyIndex = 0;
    buildPhasesForDifficulty(difficulties[difficultyIndex]);
    currentPhaseIndex = 0;
    currentWordIndex = 0;
    charIndex = 0;
    currentText = "";

    feedbackMsg.innerText = "Clique em ‚ÄúCome√ßar‚Äù para iniciar!";
    setButton("start", "Come√ßar");
  }

  updateHeader();
  textDisplay.innerHTML = "Clique em ‚ÄúCome√ßar‚Äù e digite aqui!";
  textDisplay.style.textAlign = "center";
  hideLoading();

  if (autosaveInterval) clearInterval(autosaveInterval);
  autosaveInterval = setInterval(async () => {
    if (!currentUser) return;
    if (!dirty) return;
    try { await saveProgress("interval"); }
    catch(e){ console.warn("Autosave falhou:", e?.code || e?.message || e); }
  }, 20000);
}

auth.onAuthStateChanged(async (user) => {
  if (!user){ location.href = "index.html"; return; }
  await initAfterAuth(user);
});
</script>
</body>
</html>
